%cleaner version of quenching script


% ### to do: change EgT to actually be Ev(T) and Ec(T) instead - quench t could be far from 0 K, which we are using as the Ev(0 K) = 0 referecne




%main function, takes in frozen defects, defects structure, conditions
%structure, and material properties

function[fullquench_dark_sol] = defect_fullquench_dark(equilib_sol_dummy, conditions_dummy, defects_dumy)


%%%%%  initialize the solution structure - these values are just copied
%%%%%  from the equilibrium solution
fullquench_dark_sol.T_equilibrium = equilib_sol_dummy.T_equilibrium;
fullquench_dark_sol.Nd = equilib_sol_dummy.Nd;
fullquench_dark_sol.Na = equilib_sol_dummy.Na;
fullquench_dark_sol.defect_names = equilib_sol_dummy.defect_names;
fullquench_dark_sol.chargestate_names = equilib_sol_dummy.chargestate_names;
fullquench_dark_sol.defects = equilib_sol_dummy.defects;  % for fullquenching the total number of defects is constant but charge states and n, p can change

%% these values are zero holders for the solution generated by the fullquench calc
fullquench_dark_sol.n = zeros(size(equilib_sol_dummy.n));
fullquench_dark_sol.p = zeros(size(equilib_sol_dummy.p));
fullquench_dark_sol.sth1 = zeros(size(equilib_sol_dummy.sth1));
fullquench_dark_sol.sth2 = zeros(size(equilib_sol_dummy.sth2));
fullquench_dark_sol.EFn = zeros(size(equilib_sol_dummy.EFn));
fullquench_dark_sol.EFp = zeros(size(equilib_sol_dummy.EFp));
fullquench_dark_sol.chargestates = zeros(size(equilib_sol_dummy.chargestates));
fullquench_dark_sol.charge_bal_err = zeros(size(equilib_sol_dummy.charge_bal_err));


for j = 1:size(equilib_sol_dummy.T_equilibrium, 1)  % loops over the equilibrium temperatures, keeping T_quench the same
    [guess] = FQ_EF_guess(conditions_dummy);   % get a guess for EF close to minimum using trial and error
    EF_out = fzero(@fullquench_charge_bal,guess);
    fullquench_dark_sol.EFn(j) = EF_out;
    fullquench_dark_sol.EFp(j) = EF_out;
    [fullquench_dark_sol.n(j), fullquench_dark_sol.p(j), fullquench_dark_sol.sth1(j), fullquench_dark_sol.sth2(j)] = fullquench_carrier_concentrations(EF_out);
    [fullquench_dark_sol.chargestates(j,:)] = fullquench_chargestate_concentrations(EF_out);  % compute the defect and carrier concentrations from the EF
    [fullquench_dark_sol.charge_bal_err(j)] = fullquench_charge_bal(EF_out);
end
%%%%%%%%%%%%%% end of main calc  %%%%%%%%%%%%%%%%%%





%%%%%%%%%%%%%%% nested subroutines %%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% function that uses grid search to get EF close to the charge
%%%% balance solution.  It will output two values for EF that bracket the solution unless something is strange about the charge_bal vs EF (i.e. its not monotonic   %%%%%%%%%%%%
% could change this to just guess based on net doping rather than grid
% seach
    function [guess] = FQ_EF_guess(conditions_dummy)   % keep kBT and Eg as local variables in this function

        EF_int = conditions_dummy.kBT_fullquench / conditions_dummy.fullquench_EF_search_step_divisor;   % this guarantees you can't miss the solution whcih should be thus within kB/2 of the guess
        EF_grid = (conditions_dummy.EvT_fullquench - 5*conditions_dummy.kBT_fullquench) : EF_int : (ceil(conditions_dummy.EgT_fullquench/EF_int)*EF_int + 5*conditions_dummy.kBT_fullquench);  % this makes a grid to check over the range -5kBT to Eg+5kBT.  This is ok since we have Fermi-Dirac stats
        nn = size(EF_grid,2);
        errs = zeros(1,nn);

        for i=1:nn
            guess = EF_grid(i);
            errs(i)=fullquench_charge_bal(guess);
        end

        edge_index = find(diff(sign(errs))~=0);   %  this finds the rising/falling edge where error changes sign

        if sum(size(edge_index)==[1 1])==2
            min_index = [edge_index edge_index+1];   % so we are finding the two guesses that bracket the solution one + and one -
            %     elseif sum(size(edge_index)~=[1 1])==2
            %         disp('waring: charge balance error may not be monotonic')
        elseif sum(size(edge_index)==[1 2])==2
            min_index = edge_index;
        else
            error('something strange about charge balance error vs EF - solutions may not be valid')
        end

        guess = EF_grid(min_index);
        %
        % %%%% plot the charge balance error function vs EF position if you like
        % figure(1)
        % clf
        % plot(EF_grid,errs)
        % hold on
        % plot(EF_grid(min_index),errs(min_index),'ro')  %plot the EF_guess

    end    %%%% end EF_guess





%%%% function that computes the net charge
    function charge_bal = fullquench_charge_bal(EF_dummy)
        [n, p, sth1, sth2] = fullquench_carrier_concentrations(EF_dummy);
        [N_chargestates_fullquench] = fullquench_chargestate_concentrations(EF_dummy);
        charge_bal = (sum( defects_dumy.cs_charge.* N_chargestates_fullquench') + p + sth1 + sth2 - n + conditions_dummy.Nd - conditions_dummy.Na);
    end
%%%% end charge_bal   %%%%%%%%%%%%%





%% Given EF and total number of each defect type, figure out the number of each charge state.

    function [N_chargestates_fullquench] = fullquench_chargestate_concentrations(EF_dummy)

        % set up arrays
        N_chargestates_fullquench = zeros(1,defects_dumy.num_chargestates);
        Z = zeros(1,defects_dumy.num_defects);

        % calculate Boltzmann factors for all charge states
        dH_rel = defects_dumy.cs_dHo + defects_dumy.cs_charge * EF_dummy;  % the formation enthalpy of the defects without the chem potential term (quench assumes no mass exchange)
        Boltz_facs = exp(-dH_rel/conditions_dummy.kBT_fullquench);

        for i = 1:defects_dumy.num_defects  % loop over defects (defect.cs_ID) - not over charge states
            indices = defects_dumy.cs_ID == i;  % find the indices of the charge states of the ith defect
            Z(i) = sum(Boltz_facs(indices)); % matrix with Z value for each defect (computed from Boltz factors for each charge state in that defect
            N_chargestates_fullquench(indices) = Boltz_facs(indices)/Z(i) * equilib_sol_dummy.defects(j,i);     % equilib_dark_sol.defects(j,i) is a scalar, Z(i) is a scalar
        end

    end  %%%% end concentrations





    function [n, p, sth1, sth2] = fullquench_carrier_concentrations(EF_dummy)
        %%%% function to compute n and p.  Input must be EF only (scalar
        %%%% not vector with mu's attached)  %%%%%%%%%%%%
        etaCB = (EF_dummy - conditions_dummy.EcT_fullquench)/conditions_dummy.kBT_fullquench;
        etaVB = (EF_dummy - conditions_dummy.EvT_fullquench)/conditions_dummy.kBT_fullquench;   % this looks wrong (not symmetric compared to CB case) but it is right. Direction of integration and sign on EF-Ev are both swapped.
        etaSTH1 = (EF_dummy - (conditions_dummy.EvT_fullquench + conditions_dummy.E_relax_sth1) )/conditions_dummy.kBT_fullquench;
        etaSTH2 = (EF_dummy - (conditions_dummy.EvT_fullquench + conditions_dummy.E_relax_sth2) )/conditions_dummy.kBT_fullquench;

        if strcmp(conditions_dummy.Boltz_or_FD_flag,'FD')            % use Fermi-Dirac integrals so degenerate conditions handled correctly
            n = n_Fermi_Dirac(etaCB, conditions_dummy.NcT_fullquench);
            p = n_Fermi_Dirac(-etaVB, conditions_dummy.NvT_fullquench);
            sth1 = conditions_dummy.sth_flag * n_Fermi_Dirac(-etaSTH1, conditions_dummy.num_sites(3));
            sth2 = conditions_dummy.sth_flag * n_Fermi_Dirac(-etaSTH2, conditions_dummy.num_sites(4));
        elseif strcmp(conditions_dummy.Boltz_or_FD_flag,'Boltz')              % %     use just Boltzmann approx
            n = conditions_dummy.NcT_fullquench * exp(etaCB);   % these are right (sign swap).  Boltzmann factors should end up <1 when EF is in gap
            p = conditions_dummy.NvT_fullquench * exp(-etaVB);
            sth1 = conditions_dummy.sth_flag * conditions_dummy.num_sites(3) * exp(-etaSTH1);
            sth2 = conditions_dummy.sth_flag * conditions_dummy.num_sites(4) * exp(-etaSTH2);
        else
            error('Boltz_or_FD_flag must be Boltz or FD')
        end

    end









end   %%%%%end main function

